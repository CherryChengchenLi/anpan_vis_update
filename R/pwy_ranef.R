#' Estimate a species-pathway abundance random effects model
#' @description Fit a model of the form pwy_abd ~ species_abd + (1|pwy) + (0+group|pwy) for a single
#'   bug
#' @details The priors are as follows: A) student_t(3, mean(pwy_abd), 2.5) on the intercept at the
#'   mean species abundance. B) half student_t(3, 0, 2.5) on the residual noise C) 0-centered normal
#'   priors on pathway specific effects C1) half student_t(5,0,2.5) on the SD of pathway intercepts
#'   C2) half standard normal on the SD of group-specific effects.
#'
#'   The pathway index is generated by converting the pwy column to a factor and then to the
#'   corresponding integer index.
#'
#'   The group_ind column should be numeric with values in {0,1}
#'
#'   The main parameter of interest are the elements of the  \code{pwy_effects} parameter. The "hit"
#'   column is defined by by selecting the bug:pwy combinations where 98% posterior intervals for
#'   the pwy:group effect exclude 0 and the absolute posterior mean exceeds the specified effect
#'   size threshold.
#' @param bug_pwy_dat a data frame with a row for each observation and columns "pwy",
#'   "log10_species_abd", "log10_pwy_abd", and a group indicator column named according to the
#'   \code{group_ind} argument
#' @param group_ind a character giving the name of the column for the 0/1 group indicator variable
#'   in \code{bug_pwy_dat}
#' @param effect_size_threshold effect size threshold for hit-calling pathway:group effects
#' @param ... other arguments to pass to cmdstanr::sample()
#' @returns a list containing the CmdStanMCMC object of the model fit and a summary data frame.
#' @seealso [cmdstanr::CmdStanMCMC()]
#' @export
anpan_pwy_ranef = function(bug_pwy_dat,
                           group_ind = "crc",
                           effect_size_threshold = log10(1.5),
                           ...) {

  if (!all(c("pwy", "log10_species_abd", "log10_pwy_abd", group_ind) %in% names(bug_pwy_dat))) {
    stop("The necessary variables are not present in bug_pwy_dat. See ?anpan_pwy_ranef for what the columns should be called.")
  }

  if (!is.factor(bug_pwy_dat$pwy)) {
    warning("Converting the pwy column to a factor.")
  }

  model_path = system.file("stan", "pwy_ranef.stan",
                           package = 'anpan',
                           mustWork = TRUE)

  pwy_ranef_model = cmdstanr::cmdstan_model(stan_file = model_path,
                                            quiet = TRUE)

  data_list = list(N = nrow(bug_pwy_dat),
                   pwy_abd = bug_pwy_dat$log10_pwy_abd,
                   pwy_mean = mean(bug_pwy_dat$log10_pwy_abd),
                   intercept_species = model.matrix(~log10_species_abd, data = bug_pwy_dat),
                   N_pwy = dplyr::n_distinct(bug_pwy_dat$pwy),
                   pwy_ind = as.integer(factor(bug_pwy_dat$pwy)),
                   group_ind = bug_pwy_dat[[group_ind]])

  pwy_ind_map = tibble(index = 1:data_list$N_pwy,
                       pwy_group_effect = paste("pwy_effects[", index, "]", sep = ""),
                       pwy_intercept = paste("pwy_intercepts[", index, "]", sep = ""),
                       pwy = levels(factor(bug_pwy_dat$pwy))) |>
    tidyr::pivot_longer(matches("pwy_"),
                        names_to = 'var_names',
                        values_to = 'variable') |>
    dplyr::select(-var_names) |>
    data.table::as.data.table()

  mod_fit = pwy_ranef_model$sample(data = data_list, ...)

  summary_df = mod_fit$draws() |>
    posterior::summarise_draws(posterior::default_summary_measures(),
                               wide = ~purrr::set_names(quantile(.x, probs = c(.01, .99)), c("q1", "q99")),
                               posterior::default_convergence_measures()) |>
    filter(grepl("^pwy|global|sigma|sd_|species_beta", variable)) |>  # Discard variables most users won't be interested in like lp, lprior
    dplyr::left_join(pwy_ind_map, by = 'variable') |>
    mutate(hit = (!(q1 < 0 & q99 > 0)) & (abs(mean) > effect_size_threshold)) |>
    select(pwy, hit, variable:ess_tail)

  summary_df$hit[!grepl("^pwy_eff", summary_df$variable)] = NA

  return(tibble(model_fit = list(mod_fit),
                summary_df = list(summary_df)))
}

#' Fit the pathway random effects model for multiple bugs
#' @details In addition to the column requirements of \code{anpan_pwy_ranef()}, the input data frame
#'   \code{bug_pwy_dat} here must also contain a variable called "bug" which gives a unique
#'   identifier for each bug.
#' @returns a tibble of row-binded anpan_pwy_ranef results
#' @inheritParams anpan_pwy_ranef
#' @export
anpan_pwy_ranef_batch = function(bug_pwy_dat,
                                 group_ind = "crc", ...) {

  if (!all(c("bug", "pwy", "log10_species_abd", "log10_pwy_abd", group_ind) %in% names(bug_pwy_dat))) {
    stop("The necessary variables are not present in bug_pwy_dat. See ?anpan_pwy_ranef for what the columns should be called.")
  }

  model_path = system.file("stan", "pwy_ranef.stan",
                           package = 'anpan',
                           mustWork = TRUE)

  # Compile it once ahead of time
  pwy_ranef_model = cmdstanr::cmdstan_model(stan_file = model_path,
                                            quiet = TRUE)

  p = progressr::progressor(steps = dplyr::n_distinct(bug_pwy_dat$bug))

  if (!is.data.table(bug_pwy_dat)) {
    message("Converting input to data.table")
    bug_pwy_dat = data.table::as.data.table(bug_pwy_dat)
  }

  if (!is.factor(bug_pwy_dat$bug)) {
    message("Converting bug column to factor")

    bug_pwy_dat = bug_pwy_dat |>
      mutate(bug = factor(bug))
  }


  res = split(x = bug_pwy_dat, by = "bug") |>
    furrr::future_map_dfr(function(.x) {bug_res = anpan_pwy_ranef(bug_pwy_dat = .x,
                                                                  group_ind = group_ind,
                                                                  ...)
                                        p()
                                        return(bug_res)},
                          .options = furrr::furrr_options(seed = 123),
                          .id = "bug")

  return(res)
}
