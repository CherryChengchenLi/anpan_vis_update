---
title: "anpan tutorial"
output: 
  html_document:
    toc: true
    toc_float: true
    toc_depth: 2
    code_folding: show
vignette: >
  %\VignetteIndexEntry{anpan_tutorial}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction.

It's difficult to find associations between microbial strains and host health outcomes due to their fine resolution and non-recurrence across individuals. This package, anpan, aims to make inferring those relationships a bit easier by providing an interface to our strain analysis functionality. This functionality covers three main points:

* Adaptive sample filtering of per-bug microbial gene profiles to identify and discard samples in which the bug is not present
* Modeling the association between outcome variables and microbial gene presence while accounting for covariates
* Modeling the association between outcome variables and the phylogeny of strains within a given microbial species

We'll cover the last point first in the section on [PGLMMs].

## Libraries

We'll start by loading the library in this code chunk:

```{r}
library(anpan)
```

The startup message points out that you can easily parallelize most long-running computations in `anpan` by setting `plan()` and `handlers()`. In my

This code chunk loads some other packages we'll use.
```{r message = FALSE, warning=FALSE, class.source = "fold-show"}
library(tibble)
library(dplyr)
library(ape)
```

## PGLMMs

To demonstrate the PGLMM functionality, we'll simulate a tree, a single covariate `x`, and an outcome variable `y`. We'll use `n = 100`, `sigma_phylo = 1` and `sigma_resid = 1`. 

This chunk sets a randomization seed, the parameters we'll use, and generates a random tree:

```{r eval = TRUE}
set.seed(1234)

n = 100
sigma_phylo = 1
sigma_resid = 1

tr = ape::rtree(n)
```

You can try `plot(tr)` if you want to take a quick look at your tree, but we'll examine it with some additional detail later later.

This chunk derives the correlation matrix implied by the tree:
```{r}
cov_mat = ape::vcv.phylo(tr)
s       = sqrt(diag(cov_mat))
cor_mat = diag(1/s) %*% cov_mat %*% diag(1/s) 

rownames(cor_mat) = rownames(cov_mat)
colnames(cor_mat) = colnames(cov_mat)
cor_mat[1:5,1:5]
```

The "t#" labels are the default sample IDs that `ape::rtree()` puts as tip labels.


This chunk generates a normally distributed covariate `covariate`, the true phylogenetic effects we'll use, and the outcome variable `outcome`.
```{r}
covariate = rnorm(n)

true_phylo_effects = sigma_phylo * MASS::mvrnorm(1, mu = rep(0, n), Sigma = cor_mat)

metadata = tibble(sample_id = colnames(cov_mat),
                  covariate = covariate,
                  outcome   = true_phylo_effects +
                              rnorm(n, mean = covariate, sd = sigma_resid))

head(metadata)
```

Now we have our tree and the metadata that goes along with it. We can use the function `anpan::plot_outcome_tree()` to show the tree with outcome as a dot on each leaf.

```{r fig.retina=3}
plot_outcome_tree(tr, metadata, 
                  covariates = NULL,
                  outcome = 'outcome')
```

You can sort of see by eye that the phylogeny impacts the outcome. The left side is a bit brighter, and close neighbors usually have about the same shade of color. We can assess this pattern statistically with a PGLMM.

The code chunk below shows how to use `anpan` to fit a PGLMM that examines this data for phylogenetic patterns while adjusting for our covariate. It will take a couple minutes to run. By default `anpan_pglmm` regularizes the noise ratio `sigma_phylo / sigma_resid` with a Gamma(1,2) prior and runs a leave-one-out model comparison against a "base" model that doesn't have the phylogenetic component. The default `family = "gaussian"` argument means the residual error is normally distributed. This can be changed to `family = "binomial"` with a binary outcome to run a phylogenetic logistic regression. 

```{r eval = TRUE, message=FALSE, results = "hide", warning=FALSE}
result = anpan_pglmm(meta_file      = metadata,
                     tree_file      = tr,
                     outcome        = "outcome",
                     covariates     = "covariate",
                     family         = "gaussian",
                     reg_noise      = TRUE,
                     loo_comparison = TRUE,
                     refresh        = 500)
```

By default this command prints two plots (and a lot of console output with messages about the progression of the MCMC sampler). These plots show:

* The correlation matrix implied by the tree 
* The same outcome tree as before, but now there's a lower panel showing the posterior predictive distribution for each leaf as a boxplot, overlaid with the true value.

`result` is a list with five elements:

* `model_input` - the input metadata that made it into the analysis after taking the samples that overlapped with the leaves of the tree.
* `cor_mat` - the correlation matrix derived from the tree
* `pglmm_fit` - a [CmdStanMCMC](https://mc-stan.org/cmdstanr/reference/CmdStanMCMC.html) object containing the PGLMM fit
* `base_fit` - another [CmdStanMCMC](https://mc-stan.org/cmdstanr/reference/CmdStanMCMC.html) object containing the "base" GLM fit (without the phylogenetic component)
* `loo` - a list containing three elements: 
    * `pglmm_loo` - a [loo](https://mc-stan.org/loo/) result for the PGLMM model using integrated importance weights
    * `base_loo` - a [loo](https://mc-stan.org/loo/) result for the base model
    * `comparison` - a [loo_compare()](https://mc-stan.org/loo/reference/loo_compare.html) result comparing the two models by leave-one-out predictive performance.
    
The  `pglmm_fit` part of the result is the model fit produced by `cmdstanr` for the PGLMM. Any method applicable to [CmdStanMCMC objects](https://mc-stan.org/cmdstanr/reference/CmdStanMCMC.html) works on this, but of particular interest is the summary method, which we demonstrate here to examine the posterior means for the covariate effects `beta`, the intercept, noise terms `sigma_resid` and `sigma_phylo` and the per-leaf phylogenetic effects (which are indexed in the same order as `model_input`):

```{r}
result$pglmm_fit$summary() |> 
  filter(grepl("beta|Intercept|sigma|phylo_effect", variable))
```
We can see that the posterior mean for beta is fairly close to the true value (1), as is the intercept (0) and noise terms. Importantly, the 90% posterior intervals capture the true values.

Let's look at the `pglmm_loo` result:

```{r}
result$loo$pglmm_loo
```

PGLMM models are very flexible because they have a parameter for every leaf. The loo result produces some diagnostics that can help confirm that the importance weights `loo()` uses for model comparison are stable/trustworthy. In this case, we get one Pareto k diagnostic value that is only "okay". If there are bad or "very bad" k values, that indicates that individual observations are having a strong effects on the model fit, and hence that the loo-based model comparison shouldn't be trusted. That scenario can happen more frequently without regularization when `reg_noise = FALSE`. We only got 1 non-good result, so in this case the model comparison should be okay.

Let's look at the model comparison:

```{r}
result$loo$comparison
```

`loo` prints the model with the best fit on the first row, in this case the PGLMM fit. The difference in expected log pointwise predictive density (ELPD) compared to the other model is shown in the first column along with a standard error on the difference in the second column. Here the ELPD difference is about -14.7 with a SE around +/- 5. So in this we would conclude that the phylogenetic component of the PGLMM clearly fits better than the base linear model.

## Element testing

This section isn't done.

```{r eval = FALSE}
anpan_batch()
```

## References

## Session Info

```{r}
sessionInfo()
```


